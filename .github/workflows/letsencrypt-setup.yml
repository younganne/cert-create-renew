name: Let's Encrypt Certificate Setup with Route53

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - create
          - renew
        default: 'create'
      domain:
        description: 'Domain to obtain/renew certificate for'
        required: true
      email:
        description: 'Email for Let''s Encrypt notifications'
        required: true
      verification_method:
        description: 'Certificate verification method'
        required: true
        type: choice
        options:
          - dns
          - http
        default: 'dns'
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      hosted_zone_id:
        description: 'AWS Route53 Hosted Zone ID (required for DNS verification)'
        required: false
      webroot_path:
        description: 'Web root path (required for HTTP verification)'
        required: false
        default: '/var/www/html'
      upload_certs:
        description: 'Upload certificates to remote server'
        type: boolean
        default: false
      remote_host:
        description: 'Remote server hostname'
        required: false
      remote_user:
        description: 'Remote server username'
        required: false
      remote_path:
        description: 'Remote path to upload certificates'
        required: false
        default: '/etc/ssl/private'

permissions:
  id-token: write
  contents: read

jobs:
  setup-certificate:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install AWS CLI and Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3
          sudo apt-get update
          sudo apt-get install -y certbot python3-certbot-dns-route53
          sudo systemctl stop certbot.timer || true  # Stop any running certbot timers

      - name: Create certificate setup script
        run: |
          cat > setup_certificate.py << 'EOL'
          #!/usr/bin/env python3
          import subprocess
          import sys
          import os
          import argparse
          import json
          import time
          import boto3
          from typing import List, Tuple, Optional

          def run_command(command: List[str]) -> Tuple[int, str, str]:
              try:
                  process = subprocess.Popen(
                      command,
                      stdout=subprocess.PIPE,
                      stderr=subprocess.PIPE,
                      universal_newlines=True
                  )
                  stdout, stderr = process.communicate()
                  return process.returncode, stdout, stderr
              except Exception as e:
                  return 1, "", str(e)

          def check_route53_access(hosted_zone_id: str) -> bool:
              """Verify access to Route53 hosted zone"""
              try:
                  route53 = boto3.client('route53')
                  response = route53.get_hosted_zone(Id=hosted_zone_id)
                  print(f"Successfully accessed hosted zone: {response['HostedZone']['Name']}")
                  return True
              except Exception as e:
                  print(f"Error accessing Route53 hosted zone: {e}")
                  return False

          def install_certbot() -> bool:
              """Install Certbot and its dependencies"""
              print("Installing Certbot...")
              
              commands = [
                  ["apt-get", "update"],
                  ["apt-get", "install", "-y", "software-properties-common"],
                  ["apt-get", "install", "-y", "certbot"]
              ]
              
              for cmd in commands:
                  code, stdout, stderr = run_command(cmd)
                  if code != 0:
                      print(f"Error during installation: {stderr}")
                      return False
              return True

          def manage_certificate(domain: str, email: str, verification_method: str = "dns", 
                            hosted_zone_id: str = None, webroot_path: str = None,
                            action: str = "create", staging: bool = False) -> bool:
              """
              Manage Let's Encrypt certificate using either DNS or HTTP verification
              
              Args:
                  domain: Domain name for the certificate
                  email: Contact email address
                  verification_method: Either "dns" or "http"
                  hosted_zone_id: AWS Route53 Hosted Zone ID (for DNS verification)
                  webroot_path: Web root path (for HTTP verification)
                  action: Either "create" or "renew"
                  staging: Whether to use Let's Encrypt staging environment
              """
              action_word = "Renewing" if action == "renew" else "Obtaining"
              print(f"{action_word} certificate for {domain} using {verification_method.upper()} verification...")
              
              # Create certbot config directory
              os.makedirs("/etc/letsencrypt", exist_ok=True)
              
              # Base command
              cmd = [
                  "certbot",
                  "renew" if action == "renew" else "certonly",
                  "--non-interactive",
                  "--agree-tos",
                  "-m", email,
                  "--server", "https://acme-v02.api.letsencrypt.org/directory"
              ]
              
              # Add verification method-specific arguments
              if verification_method == "dns":
                  if not hosted_zone_id:
                      print("Error: hosted_zone_id is required for DNS verification")
                      return False
                  cmd.extend([
                      "--dns-route53",
                      "--preferred-challenges", "dns-01"
                  ])
              else:  # HTTP verification
                  if not webroot_path:
                      print("Error: webroot_path is required for HTTP verification")
                      return False
                  cmd.extend([
                      "--webroot",
                      "-w", webroot_path,
                      "--preferred-challenges", "http-01"
                  ])
              
              # Add staging flag if needed
              if staging:
                  cmd.append("--test-cert")
              
              # Only add domain for new certificates
              if action == "create":
                  cmd.extend(["-d", domain])
              
              # Run certbot command
              code, stdout, stderr = run_command(cmd)
              if code != 0:
                  print(f"Error obtaining certificate: {stderr}")
                  return False
                  
              print(stdout)
              return True
              
              # Only add domain for new certificates
              if action == "create":
                  cmd.extend(["-d", domain])
              
              if staging:
                  cmd.append("--test-cert")
              
              cmd.extend(["-d", domain])
              
              # Set AWS Route53 zone ID for certbot
              os.environ['CERTBOT_DOMAIN'] = domain
              os.environ['CERTBOT_VALIDATION'] = hosted_zone_id
              
              code, stdout, stderr = run_command(cmd)
              if code != 0:
                  print(f"Error obtaining certificate: {stderr}")
                  return False
                  
              print(stdout)
              return True

          def export_certificates(domain: str) -> bool:
              """Export certificates to GitHub Actions artifacts"""
              cert_dir = f"/etc/letsencrypt/live/{domain}"
              if not os.path.exists(cert_dir):
                  print(f"Certificate directory not found: {cert_dir}")
                  return False

              os.makedirs("certificates", exist_ok=True)
              
              try:
                  for file in ["fullchain.pem", "privkey.pem", "chain.pem", "cert.pem"]:
                      src = os.path.join(cert_dir, file)
                      dst = os.path.join("certificates", file)
                      with open(src, 'rb') as f_src, open(dst, 'wb') as f_dst:
                          f_dst.write(f_src.read())
                  
                  # Export certificate info
                  code, stdout, stderr = run_command(["certbot", "certificates"])
                  if code == 0:
                      with open("certificates/cert_info.txt", "w") as f:
                          f.write(stdout)
                  
                  return True
              except Exception as e:
                  print(f"Error exporting certificates: {e}")
                  return False

          def main():
              parser = argparse.ArgumentParser(description="Automate Let's Encrypt certificate management")
              parser.add_argument("domain", help="Domain name to manage certificate for")
              parser.add_argument("email", help="Email address for important notifications")
              parser.add_argument("--action", choices=["create", "renew"], default="create", help="Action to perform")
              parser.add_argument("--verification", choices=["dns", "http"], default="dns", help="Verification method")
              parser.add_argument("--hosted-zone-id", help="AWS Route53 Hosted Zone ID (for DNS verification)")
              parser.add_argument("--webroot-path", help="Web root path (for HTTP verification)")
              parser.add_argument("--staging", action="store_true", help="Use Let's Encrypt staging environment")
              args = parser.parse_args()

              if not os.geteuid() == 0:
                  print("This script must be run as root!")
                  sys.exit(1)

              # Verify required parameters based on verification method
              if args.verification == "dns" and not args.hosted_zone_id:
                  print("Error: hosted-zone-id is required for DNS verification")
                  sys.exit(1)
              elif args.verification == "http" and not args.webroot_path:
                  print("Error: webroot-path is required for HTTP verification")
                  sys.exit(1)

              steps = [
                  ("Installing Certbot", install_certbot)
              ]

              # Add verification method-specific steps
              if args.verification == "dns":
                  steps.append(("Verifying Route53 access", lambda: check_route53_access(args.hosted_zone_id)))
              else:  # HTTP verification
                  steps.extend([
                      ("Installing web server dependencies", install_webserver_dependencies),
                      ("Checking web server configuration", lambda: check_webserver_configuration(args.domain, args.webroot_path))
                  ])

              # Add certificate management step
              steps.append(
                  (f"{'Renewing' if args.action == 'renew' else 'Obtaining'} certificate", 
                   lambda: manage_certificate(
                       args.domain, 
                       args.email, 
                       args.verification,
                       args.hosted_zone_id,
                       args.webroot_path,
                       args.action,
                       args.staging
                   ))
              )

              # Add export step
              steps.append(("Exporting certificates", lambda: export_certificates(args.domain)))

              for step_name, step_func in steps:
                  print(f"\n=== {step_name} ===")
                  if not step_func():
                      print(f"\nError during {step_name.lower()}. Exiting.")
                      sys.exit(1)

              print("\nSuccess! Certificates have been obtained and exported.")

          if __name__ == "__main__":
              main()
          EOL
          chmod +x setup_certificate.py

      - name: Setup SSH key
        if: ${{ inputs.upload_certs == true }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ inputs.remote_host }} >> ~/.ssh/known_hosts

      - name: Run certificate management
        run: |
          sudo -E ./setup_certificate.py \
            ${{ github.event.inputs.domain }} \
            ${{ github.event.inputs.email }} \
            --action ${{ github.event.inputs.action }} \
            --verification ${{ github.event.inputs.verification_method }} \
            ${{ github.event.inputs.verification_method == 'dns' && format('--hosted-zone-id {0}', github.event.inputs.hosted_zone_id) || '' }} \
            ${{ github.event.inputs.verification_method == 'http' && format('--webroot-path {0}', github.event.inputs.webroot_path) || '' }} \
            ${{ github.event.inputs.environment == 'staging' && '--staging' || '' }}

      - name: Upload certificates to remote server
        if: ${{ inputs.upload_certs == true }}
        run: |
          scp -r certificates/* ${{ inputs.remote_user }}@${{ inputs.remote_host }}:${{ inputs.remote_path }}/
          # Verify upload
          ssh ${{ inputs.remote_user }}@${{ inputs.remote_host }} "ls -l ${{ inputs.remote_path }}"

      - name: Cleanup sensitive files
        if: always()
        run: |
          sudo rm -rf certificates/
          sudo rm -f setup_certificate.py
          rm -f ~/.ssh/id_rsa