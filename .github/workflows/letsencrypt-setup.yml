name: Let's Encrypt Certificate Setup with Route53

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Domain to obtain certificate for'
        required: true
      email:
        description: 'Email for Let''s Encrypt notifications'
        required: true
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      hosted_zone_id:
        description: 'AWS Route53 Hosted Zone ID'
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  setup-certificate:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install AWS CLI and Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 certbot certbot-dns-route53
          sudo apt-get update
          sudo apt-get install -y python3-certbot python3-certbot-dns-route53

      - name: Create certificate setup script
        run: |
          cat > setup_certificate.py << 'EOL'
          #!/usr/bin/env python3
          import subprocess
          import sys
          import os
          import argparse
          import json
          import time
          import boto3
          from typing import List, Tuple, Optional

          def run_command(command: List[str]) -> Tuple[int, str, str]:
              try:
                  process = subprocess.Popen(
                      command,
                      stdout=subprocess.PIPE,
                      stderr=subprocess.PIPE,
                      universal_newlines=True
                  )
                  stdout, stderr = process.communicate()
                  return process.returncode, stdout, stderr
              except Exception as e:
                  return 1, "", str(e)

          def check_route53_access(hosted_zone_id: str) -> bool:
              """Verify access to Route53 hosted zone"""
              try:
                  route53 = boto3.client('route53')
                  response = route53.get_hosted_zone(Id=hosted_zone_id)
                  print(f"Successfully accessed hosted zone: {response['HostedZone']['Name']}")
                  return True
              except Exception as e:
                  print(f"Error accessing Route53 hosted zone: {e}")
                  return False

          def install_certbot() -> bool:
              """Install Certbot and its dependencies"""
              print("Installing Certbot...")
              
              commands = [
                  ["apt-get", "update"],
                  ["apt-get", "install", "-y", "software-properties-common"],
                  ["apt-get", "install", "-y", "certbot"]
              ]
              
              for cmd in commands:
                  code, stdout, stderr = run_command(cmd)
                  if code != 0:
                      print(f"Error during installation: {stderr}")
                      return False
              return True

          def obtain_certificate(domain: str, email: str, hosted_zone_id: str, staging: bool = False) -> bool:
              """
              Obtain Let's Encrypt certificate using DNS validation with Route53
              """
              print(f"Obtaining certificate for {domain}...")
              
              # Create certbot config directory
              os.makedirs("/etc/letsencrypt", exist_ok=True)
              
              # Create Route53 config file
              config_content = '''
              dns_route53_propagation_seconds = 30
              '''
              with open("/etc/letsencrypt/cli.ini", "w") as f:
                  f.write(config_content)
              
              cmd = [
                  "certbot", "certonly",
                  "--dns-route53",
                  "--non-interactive",
                  "--agree-tos",
                  "-m", email,
                  "--preferred-challenges", "dns-01"
              ]
              
              if staging:
                  cmd.append("--test-cert")
              
              cmd.extend(["-d", domain])
              
              # Set AWS Route53 zone ID for certbot
              os.environ['CERTBOT_DOMAIN'] = domain
              os.environ['CERTBOT_VALIDATION'] = hosted_zone_id
              
              code, stdout, stderr = run_command(cmd)
              if code != 0:
                  print(f"Error obtaining certificate: {stderr}")
                  return False
                  
              print(stdout)
              return True

          def export_certificates(domain: str) -> bool:
              """Export certificates to GitHub Actions artifacts"""
              cert_dir = f"/etc/letsencrypt/live/{domain}"
              if not os.path.exists(cert_dir):
                  print(f"Certificate directory not found: {cert_dir}")
                  return False

              os.makedirs("certificates", exist_ok=True)
              
              try:
                  for file in ["fullchain.pem", "privkey.pem", "chain.pem", "cert.pem"]:
                      src = os.path.join(cert_dir, file)
                      dst = os.path.join("certificates", file)
                      with open(src, 'rb') as f_src, open(dst, 'wb') as f_dst:
                          f_dst.write(f_src.read())
                  
                  # Export certificate info
                  code, stdout, stderr = run_command(["certbot", "certificates"])
                  if code == 0:
                      with open("certificates/cert_info.txt", "w") as f:
                          f.write(stdout)
                  
                  return True
              except Exception as e:
                  print(f"Error exporting certificates: {e}")
                  return False

          def main():
              parser = argparse.ArgumentParser(description="Automate Let's Encrypt certificate installation with Route53")
              parser.add_argument("domain", help="Domain name to obtain certificate for")
              parser.add_argument("email", help="Email address for important notifications")
              parser.add_argument("hosted_zone_id", help="AWS Route53 Hosted Zone ID")
              parser.add_argument("--staging", action="store_true", help="Use Let's Encrypt staging environment")
              args = parser.parse_args()

              if not os.geteuid() == 0:
                  print("This script must be run as root!")
                  sys.exit(1)

              steps = [
                  ("Verifying Route53 access", lambda: check_route53_access(args.hosted_zone_id)),
                  ("Installing Certbot", install_certbot),
                  ("Obtaining certificate", lambda: obtain_certificate(args.domain, args.email, args.hosted_zone_id, args.staging)),
                  ("Exporting certificates", lambda: export_certificates(args.domain))
              ]

              for step_name, step_func in steps:
                  print(f"\n=== {step_name} ===")
                  if not step_func():
                      print(f"\nError during {step_name.lower()}. Exiting.")
                      sys.exit(1)

              print("\nSuccess! Certificates have been obtained and exported.")

          if __name__ == "__main__":
              main()
          EOL
          chmod +x setup_certificate.py

      - name: Run certificate setup
        run: |
          sudo -E ./setup_certificate.py \
            ${{ github.event.inputs.domain }} \
            ${{ github.event.inputs.email }} \
            ${{ github.event.inputs.hosted_zone_id }} \
            ${{ github.event.inputs.environment == 'staging' && '--staging' || '' }}

      - name: Upload certificates
        uses: actions/upload-artifact@v4
        with:
          name: certificates
          path: certificates/
          retention-days: 1

      - name: Cleanup sensitive files
        if: always()
        run: |
          sudo rm -rf certificates/
          sudo rm -f setup_certificate.py
